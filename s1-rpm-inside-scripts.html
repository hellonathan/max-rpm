<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Scripts: RPM's Workhorse</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Maximum RPM"
HREF="index.html"><LINK
REL="UP"
TITLE="Inside the Spec File"
HREF="ch-rpm-inside.html"><LINK
REL="PREVIOUS"
TITLE="Tags: Data Definitions"
HREF="s1-rpm-inside-tags.html"><LINK
REL="NEXT"
TITLE="Macros: Helpful Shorthand for Package Builders"
HREF="s1-rpm-inside-macros.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Maximum RPM: Taking the RPM Package Manager to the Limit</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="s1-rpm-inside-tags.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 13. Inside the Spec File</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="s1-rpm-inside-macros.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="S1-RPM-INSIDE-SCRIPTS"
>Scripts: RPM's Workhorse</A
></H1
><P
>        The scripts that RPM uses to control the build process are among the
        most varied and interesting parts of the spec file.  Many spec files
        also contain scripts that perform a variety of tasks whenever the
        package is installed or erased.
      </P
><P
>        The start of each script is denoted by a keyword.  For example, the
        <B
CLASS="COMMAND"
>%build</B
> keyword marks the start of the script RPM will
        execute when building the software to be packaged.  It should be noted
        that, in the strictest sense of the word, these parts of the spec file
        are not scripts.  For example, they do not start with the traditional
        invocation of a shell.  However, the contents of each script section are
        copied into a file and executed by RPM as a full-fledged script.  This
        is part of the power of RPM: Anything that can be done in a script can
        be done by RPM.
      </P
><P
>        Let's start by looking at the scripts used during the build process.
      </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="S2-RPM-INSIDE-BUILD-TIME-SCRIPTS"
>Build-time Scripts</A
></H2
><P
>          The scripts that RPM uses during the building of a package follow the steps
          known to every software developer:

          <P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>                Unpacking the sources.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                Building the software.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                Installing the software.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                Cleaning up.
              </P
></LI
></UL
>
        </P
><P
>          Although each of the scripts perform a specific function in the build
          process, they share a common environment.  Using RPM's
          <B
CLASS="COMMAND"
>--test</B
> option
          <A
NAME="AEN7910"
HREF="#FTN.AEN7910"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
          , we can see the common portion of each script.  In the following
          example, we've taken the <TT
CLASS="APPLICATION"
>cdplayer</TT
> package, issued
          an <B
CLASS="COMMAND"
>rpmbuild</B
> <B
CLASS="COMMAND"
>-ba --test cdplayer-1.0-1.spec</B
>, and viewed
          the script files left in RPM's temporary directory.  This section
          (with the appropriate package-specific values) is present in every
          script RPM executes during a build:

          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>#!/bin/sh -e
# Script generated by rpm

RPM_SOURCE_DIR="/usr/src/redhat/SOURCES"
RPM_BUILD_DIR="/usr/src/redhat/BUILD"
RPM_DOC_DIR="/usr/doc"
RPM_OPT_FLAGS="-O2 -m486 -fno-strength-reduce"
RPM_ARCH="i386"
RPM_OS="Linux"
RPM_ROOT_DIR="/tmp/cdplayer"
RPM_BUILD_ROOT="/tmp/cdplayer"
RPM_PACKAGE_NAME="cdplayer"
RPM_PACKAGE_VERSION="1.0"
RPM_PACKAGE_RELEASE="1"
set -x

umask 022</SAMP
>
          </PRE
></TD
></TR
></TABLE
>
          
        </P
><P
>          As we can see, the script starts with the usual invocation of a shell
          (in this case, the Bourne shell).  There are no arguments passed to
          the script.  Next, a number of environment variables are set.  Here's
          a brief description of each one:

          <P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_SOURCE_DIR</CODE
> &#8212; This environment variable
                gets its value from the rpmrc file entry
                <B
CLASS="COMMAND"
>sourcedir</B
>, which in turn can get part of its
                value from the <B
CLASS="COMMAND"
>topdir</B
> entry.  It is the path
                RPM will prepend to the file, specified in the
                <B
CLASS="COMMAND"
>source</B
> tag line.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_BUILD_DIR</CODE
> &#8212; This variable is based on
                the <B
CLASS="COMMAND"
>builddir</B
> rpmrc file entry, which in turn
                can get part of its value from the <B
CLASS="COMMAND"
>topdir</B
>
                entry.  This environment variable translates to the path of
                RPM's build directory, where most software will be unpacked and
                built.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_DOC_DIR</CODE
> &#8212; The value of this environment
                variable is based on the <B
CLASS="COMMAND"
>defaultdocdir</B
>
                <TT
CLASS="FILENAME"
>rpmrc</TT
> file entry.  Files marked with the
                <B
CLASS="COMMAND"
>%doc</B
> directive can be installed in a
                subdirectory of <B
CLASS="COMMAND"
>defaultdocdir</B
>.  For more
                information on the <B
CLASS="COMMAND"
>%doc</B
> directive, refer to
                <A
HREF="s1-rpm-inside-files-list-directives.html#S3-RPM-INSIDE-FLIST-DOC-DIRECTIVE"
>the Section called <I
>The <B
CLASS="COMMAND"
>%doc</B
> Directive</I
></A
>.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_OPT_FLAGS</CODE
> &#8212; This environment variable
                gets its value from the <B
CLASS="COMMAND"
>optflags</B
>
                <TT
CLASS="FILENAME"
>rpmrc</TT
> file entry.  It contains options that
                can be passed on to the build procedures of the software being
                packaged.  Normally this means either a configuration script or
                the <B
CLASS="COMMAND"
>make</B
> command itself.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_ARCH</CODE
> &#8212; As one might infer from the
                example above, this environment variable contains a string
                describing the build system's architecture.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_OS</CODE
> &#8212; This one contains the name of the
                build system's operating system.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_BUILD_ROOT</CODE
> &#8212; This environment variable
                is used to hold the "build root", into which the newly built
                software will be installed.  If no explicit build root has been
                specified (either by command line option, spec file tag line, or
                rpmrc file entry), this variable will be null.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_PACKAGE_NAME</CODE
> &#8212; This environment
                variable gets its value from the <B
CLASS="COMMAND"
>name</B
> tag
                line in the package's spec file.  It contains the name of the
                software being packaged.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_PACKAGE_VERSION</CODE
> &#8212; The
                <B
CLASS="COMMAND"
>version</B
> tag line is the source of this
                variable's translation.  Predictably, this environment variable
                contains the software's version number.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                <CODE
CLASS="ENVAR"
>RPM_PACKAGE_RELEASE</CODE
> &#8212; This environment
                variable contains the package's release number.  Its value is
                obtained from the <B
CLASS="COMMAND"
>release</B
> tag line in the
                spec file.
              </P
></LI
></UL
>
        </P
><P
>          All of these environment variables are set for your use, to make it
          easier to write scripts that will do the right thing even if the build
          environment changes.
        </P
><P
>          The script also sets an option that causes the shell to print out each
          command, complete with expanded arguments.  Finally, the default
          permissions are set.  Past this point, the scripts differ.  Let's look
          at the scripts in the order they are executed.
        </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-PREP-SCRIPT"
>The <B
CLASS="COMMAND"
>%prep</B
> Script</A
></H3
><P
>            The <B
CLASS="COMMAND"
>%prep</B
> script is the first script RPM executes
            during a build.  Prior to the <B
CLASS="COMMAND"
>%prep</B
> script, RPM
            has performed preliminary consistency checks, such as whether the
            spec file's <B
CLASS="COMMAND"
>source</B
> tag points to files that
            actually exist.  Just prior to passing control over to the
            <B
CLASS="COMMAND"
>%prep</B
> script's contents, RPM changes directory
            into RPM's build area, which, by default, is
            <TT
CLASS="FILENAME"
>/usr/src/redhat/BUILD</TT
>.
          </P
><P
>            At that point, it is the responsibility of the
            <B
CLASS="COMMAND"
>%prep</B
> script to:

            <P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>                  Create the top-level build directory.
                </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                  Unpack the original sources into the build directory.
                </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                  Apply patches to the sources, if necessary.
                </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                  Perform any other actions required to get the sources in a
                  ready-to-build state.
                </P
></LI
></UL
>
          </P
><P
>            The first three items on this list are common to the vast majority
            of all software being packaged.  Because of this, RPM has two macros
            that greatly simplify these routine functions.  More information on
            RPM's <B
CLASS="COMMAND"
>%setup</B
> and <B
CLASS="COMMAND"
>%patch</B
> macros
            can be found in <A
HREF="s1-rpm-inside-macros.html"
>the Section called <I
>Macros: Helpful Shorthand for Package Builders</I
></A
>.
          </P
><P
>            The last item on the list can include creating directories or
            anything else required to get the sources in a ready-to-build state.
            As a result, a <B
CLASS="COMMAND"
>%prep</B
> script can range from one
            line invoking a single <B
CLASS="COMMAND"
>%setup</B
> macro, to many
            lines of tricky shell programming.
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-BUILD-SCRIPT"
>The <B
CLASS="COMMAND"
>%build</B
> Script</A
></H3
><P
>            The <B
CLASS="COMMAND"
>%build</B
> script picks up where the
            <B
CLASS="COMMAND"
>%prep</B
> script left off.  Once the
            <B
CLASS="COMMAND"
>%prep</B
> script has gotten everything ready for the
            build, the <B
CLASS="COMMAND"
>%build</B
> script is usually somewhat
            anti-climactic &#8212; normally invoking <B
CLASS="COMMAND"
>make</B
>,
            maybe a configuration script, and little else.
          </P
><P
>            Like <B
CLASS="COMMAND"
>%prep</B
> before it, the
            <B
CLASS="COMMAND"
>%build</B
> script has the same assortment of
            environment variables to draw on.  Also, like
            <B
CLASS="COMMAND"
>%prep</B
>, <B
CLASS="COMMAND"
>%build</B
> changes
            directory into the software's top-level build directory (located in
            <CODE
CLASS="ENVAR"
>RPM_BUILD_DIR</CODE
>, or usually called
            <B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>&#60;name&#62;</I
></TT
>-<TT
CLASS="REPLACEABLE"
><I
>&#60;version&#62;</I
></TT
></B
>).
          </P
><P
>            Unlike <B
CLASS="COMMAND"
>%prep</B
>, there are no macros available for
            use in the <B
CLASS="COMMAND"
>%build</B
> script.  The reason is simple:
            Either the commands required to build the software are simple (such
            as a single <B
CLASS="COMMAND"
>make</B
> command), or they are so unique
            that a macro wouldn't make it easier to write the script.
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-INSTALL-SCRIPT"
>The <B
CLASS="COMMAND"
>%install</B
> Script</A
></H3
><P
>            The environment in which the <B
CLASS="COMMAND"
>%install</B
> script
            executes is identical to the other scripts.  Like the other scripts,
            the <B
CLASS="COMMAND"
>%install</B
> script's working directory is set to
            the software's top-level directory.
          </P
><P
>            As the name implies, it is this script's responsibility to do
            whatever is necessary to actually install the newly built software.
            In most cases, this means a single <B
CLASS="COMMAND"
>make install</B
>
            command, or a few commands to copy files and create directories.
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-CHECK-SCRIPT"
>The <B
CLASS="COMMAND"
>%check</B
> Script</A
></H3
><P
>            The environment in which the <B
CLASS="COMMAND"
>%check</B
> script
            executes is identical to the other scripts.  Like the other
            scripts, the <B
CLASS="COMMAND"
>%check</B
> script's working directory
            is set to the software's top-level directory.
          </P
><P
>            This script's primary function is to run the test suite of the
            built software to ensure that the binaries work correctly.
            Some typical commands to run in this script are
            <B
CLASS="COMMAND"
>make test</B
> or <B
CLASS="COMMAND"
>make check</B
>.
          </P
><P
>            The <B
CLASS="COMMAND"
>%check</B
> script is available in RPM
            version 4.2 and newer.
            <A
NAME="AEN8053"
HREF="#FTN.AEN8053"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-CLEAN-SCRIPT"
>The <B
CLASS="COMMAND"
>%clean</B
> Script</A
></H3
><P
>            The <B
CLASS="COMMAND"
>%clean</B
> script, as the name implies, is used
            to clean up the software's build directory tree.  RPM normally does
            this for you, but in certain cases (most notably in those packages
            that use a build root) you'll need to include a
            <B
CLASS="COMMAND"
>%clean</B
> script.
          </P
><P
>            As usual, the <B
CLASS="COMMAND"
>%clean</B
> script has the same set of
            environment variables as the other scripts we've covered here.
            Since a <B
CLASS="COMMAND"
>%clean</B
> script is normally used when the
            package is built in a build root, the <CODE
CLASS="ENVAR"
>RPM_BUILD_ROOT</CODE
>
            environment variable is particularly useful.  In many cases, a
            simple

            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>rm -rf $RPM_BUILD_ROOT</SAMP
>
            </PRE
></TD
></TR
></TABLE
>
            will suffice.
            <A
NAME="AEN8074"
HREF="#FTN.AEN8074"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
>
          </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="S2-RPM-INSIDE-ERASE-TIME-SCRIPTS"
>Install/Erase-time Scripts</A
></H2
><P
>          The other type of scripts that are present in the spec file are those
          that are only used when the package is either installed or erased.
          There are four scripts, each one meant to be executed at different
          times during the life of a package:

          <P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>                Before installation.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                After installation.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                Before erasure.
              </P
></LI
><LI
STYLE="list-style-type: disc"
><P
>                After erasure.
              </P
></LI
></UL
>
          
        </P
><P
>          Unlike the build-time scripts, there is little in the way of
          environment variables for these scripts.  The only environment
          variable available is <CODE
CLASS="ENVAR"
>RPM_INSTALL_PREFIX</CODE
>, and that is
          only set if the package uses an installation prefix.
        </P
><P
>          
          Unlike the build-time scripts, there <I
CLASS="EMPHASIS"
>is</I
> an
          argument defined.  The sole argument to these scripts, is a number
          representing the number of instances of the package currently
          installed on the system, <I
CLASS="EMPHASIS"
>after</I
> the current
          package has been installed or erased.  Sound tricky?  It really isn't.
          Here's an example:
        </P
><P
>          Assume that a package, called <TT
CLASS="APPLICATION"
>blather-1.0</TT
>, is
          being installed.  No previous versions of <TT
CLASS="APPLICATION"
>blather</TT
>
          have been installed.  Since the software is being installed, only the
          <B
CLASS="COMMAND"
>%pre</B
> and <B
CLASS="COMMAND"
>%post</B
> scripts are
          executed.  The argument passed to these scripts will be 1, since the
          the number of <TT
CLASS="APPLICATION"
>blather</TT
> packages installed is 1.
          <A
NAME="AEN8113"
HREF="#FTN.AEN8113"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
>
        </P
><P
>          Continuing our example, a new version of the
          <TT
CLASS="APPLICATION"
>blather</TT
> package, version 1.3, is now available.
          Clearly it's time to upgrade.  What will the scripts' values be during
          the upgrade?  As <TT
CLASS="APPLICATION"
>blather-1.3</TT
> is installing, its
          <B
CLASS="COMMAND"
>%pre</B
> and <B
CLASS="COMMAND"
>%post</B
> scripts will have
          an argument equal to 2 (1 for version 1.0 already installed, plus 1
          for version 1.3 being installed).  As the final part of the upgrade,
          it's then time to erase <TT
CLASS="APPLICATION"
>blather</TT
> version 1.0.  As
          the package is being removed, its <B
CLASS="COMMAND"
>%preun</B
> and
          <B
CLASS="COMMAND"
>%postun</B
> scripts are executed.  Since there will be
          only one <TT
CLASS="APPLICATION"
>blather</TT
> package (version 1.3) installed
          after version 1.0 is erased, the argument passed to version 1.0's
          scripts is 1.
        </P
><P
>          To finally bring an end to this example, we've decided to erase
          <TT
CLASS="APPLICATION"
>blather</TT
> 1.3.  We just don't need it anymore.  As
          the package is being erased, its <B
CLASS="COMMAND"
>%preun</B
> and
          <B
CLASS="COMMAND"
>%postun</B
> scripts will be executed.  Since there will
          be no <TT
CLASS="APPLICATION"
>blather</TT
> packages installed once the erase
          completes, the argument passed to the scripts is 0.
        </P
><P
>          With all that said, of what possible use would this argument be?
          Well, it has two very interesting properties:

          <P
></P
><OL
TYPE="1"
><LI
><P
>                When the first version of a package is installed, its
                <B
CLASS="COMMAND"
>%pre</B
> and <B
CLASS="COMMAND"
>%post</B
> scripts
                will be passed an argument equal to 1.
              </P
></LI
><LI
><P
>                When the last version of a package is erased, its
                <B
CLASS="COMMAND"
>%preun</B
> and <B
CLASS="COMMAND"
>%postun</B
> scripts
                will be passed an argument equal to 0.
              </P
></LI
></OL
>
        </P
><P
>          Based on these properties, it's trivial to write an install-time
          script that can take certain actions in specific circumstances.
          Usually, the argument is used in the <B
CLASS="COMMAND"
>%preun</B
> or
          <B
CLASS="COMMAND"
>%postun</B
> scripts to perform a special task when the
          last instance of a package is being erased.
        </P
><P
>          What is normally done during these scripts?  The exact tasks may vary,
          but in general, the tasks are any that need to be performed at these
          points in the package's existence.  One very common task is to run
          <B
CLASS="COMMAND"
>ldconfig</B
> when shared libraries are installed or
          removed.  But that's not the only use for these scripts.  It's even
          possible to use the scripts to perform tests to ensure the package
          install/erasure should proceed.
        </P
><P
>          Since each of these scripts will be executing on whatever system
          installs the package, it's necessary to choose the script's choice of
          tools carefully.  Unless you're sure a given program is going to be
          available on <I
CLASS="EMPHASIS"
>all</I
> the systems that could possibly
          install your package, you should not use it in these scripts.
        </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-PRE-SCRIPT"
>The <B
CLASS="COMMAND"
>%pre</B
> Script</A
></H3
><P
>            The <B
CLASS="COMMAND"
>%pre</B
> script executes just before the package
            is to be installed.  It is the rare package that requires anything
            to be done prior to installation; none of the 350 packages that
            comprise Red Hat Linux Linux 4.0 make use of it.
          </P
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="S4-RPM-INSIDE-POST-SCRIPT"
>The <B
CLASS="COMMAND"
>%post</B
> Script</A
></H4
><P
>              The <B
CLASS="COMMAND"
>%post</B
> script executes after the package has
              been installed.  One of the most popular reasons a
              <B
CLASS="COMMAND"
>%post</B
> script is needed is to run
              <B
CLASS="COMMAND"
>ldconfig</B
> to update the list of available shared
              libraries after a new one has been installed.  Of course, other
              functions can be performed in a <B
CLASS="COMMAND"
>%post</B
> script.
              For example, packages that install shells use the
              <B
CLASS="COMMAND"
>%post</B
> script to add the shell name to
              <TT
CLASS="FILENAME"
>/etc/shells</TT
>.
            </P
><P
>              If a package uses a <B
CLASS="COMMAND"
>%post</B
> script to perform
              some function, quite often it will include a
              <B
CLASS="COMMAND"
>%postun</B
> script that performs the inverse of the
              <B
CLASS="COMMAND"
>%post</B
> script, after the package has been
              removed.
            </P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-PREUN-SCRIPT"
>The <B
CLASS="COMMAND"
>%preun</B
> Script</A
></H3
><P
>            If there's a time when your package needs to have one last look
            around before the user erases it, the place to do it is in the
            <B
CLASS="COMMAND"
>%preun</B
> script.  Anything that a package needs to
            do immediately prior to RPM taking any action to erase the package,
            can be done here.
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="S3-RPM-INSIDE-POSTUN-SCRIPT"
>The <B
CLASS="COMMAND"
>%postun</B
> Script</A
></H3
><P
>            The <B
CLASS="COMMAND"
>%postun</B
> script executes after the package has
            been removed.  It is the last chance for a package to clean up after
            itself.  Quite often, <B
CLASS="COMMAND"
>%postun</B
> scripts are used to
            run <B
CLASS="COMMAND"
>ldconfig</B
> to remove newly erased shared
            libraries from <TT
CLASS="FILENAME"
>ld.so.cache</TT
>.
          </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="S2-RPM-INSIDE-VERIFYSCRIPT-SCRIPT"
>Verification-Time Script &#8212; The <B
CLASS="COMMAND"
>%verifyscript</B
>
          Script</A
></H2
><P
>          The <B
CLASS="COMMAND"
>%verifyscript</B
> executes whenever the installed
          package is verified by RPM's verification command.  The contents of
          this script is entirely up to the package builder, but in general the
          script should do whatever is necessary to verify the package's proper
          installation.  Since RPM automatically verifies the existence of a
          package's files, along with other file attributes, the
          <B
CLASS="COMMAND"
>%verifyscript</B
> should concentrate on different
          aspects of the package's installation.  For example, the script may
          ensure that certain configuration files contain the proper information
          for the package being verified:

          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>for n in ash bsh; do
    echo -n "Looking for $n in /etc/shells... "
    if ! grep "^/bin/${n}\$" /etc/shells &#62; /dev/null; then
        echo "missing"
        echo "${n} missing from /etc/shells" &#62;&#38;2
    else
        echo "found"
    fi
done</SAMP
>
          </PRE
></TD
></TR
></TABLE
>
        </P
><P
>          In this script, the config file <TT
CLASS="FILENAME"
>/etc/shells</TT
>, is
          checked to ensure that it has entries for the shells provided by this
          package.
        </P
><P
>          It is worth noting that the script sends informational and error
          messages to stdout, and error messages only to stderr.  Normally RPM
          will only display error output from a verification script; the output
          sent to stdout is only displayed when the verification is run in
          verbose mode.

        </P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN7910"
HREF="s1-rpm-inside-scripts.html#AEN7910"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>              Described in <A
HREF="ch-rpm-b-command.html#S2-RPM-B-COMMAND-TEST-OPTION"
>the Section called <I
><B
CLASS="COMMAND"
>--test</B
> &#8212; Create, Save Build Scripts For
          Review</I
> in Chapter 12</A
>.
            </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8053"
HREF="s1-rpm-inside-scripts.html#AEN8053"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>                One popular hack to make spec files containing the
                <B
CLASS="COMMAND"
>%check</B
> script "work" with RPM versions
                older than 4.2 roughly similarly as in newer versions is to
                include it immediately after the <B
CLASS="COMMAND"
>%install</B
>
                script in the spec file and append "|| :" to it, like:
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>%check || :</SAMP
>
                </PRE
></TD
></TR
></TABLE
>
              </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8074"
HREF="s1-rpm-inside-scripts.html#AEN8074"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>                Keep in mind that this command in a <B
CLASS="COMMAND"
>%clean</B
>
                script can wreak havoc if used with a build root of, say,
                <TT
CLASS="FILENAME"
>/</TT
>.  <A
HREF="ch-rpm-b-command.html#S3-RPM-B-COMMAND-BUILDROOT-WARNING"
>the Section called <I
>Using <B
CLASS="COMMAND"
>--buildroot</B
> Can Bite You!</I
> in Chapter 12</A
>
                discusses this in more detail.
              </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8113"
HREF="s1-rpm-inside-scripts.html#AEN8113"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>              Or it will be 1, once the package is completely installed.
              Remember, the number is based on the number of packages installed
              <I
CLASS="EMPHASIS"
>after</I
> the current package's install or erase
              has completed.
            </P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="s1-rpm-inside-tags.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="s1-rpm-inside-macros.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Tags: Data Definitions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ch-rpm-inside.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Macros: Helpful Shorthand for Package Builders</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>